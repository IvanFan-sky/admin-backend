# 项目设计文档

## 1. 文档概述

### 1.1 文档目的
本文档旨在详细描述Admin管理系统的项目设计，包括详细设计、接口设计、组件设计、安全设计等内容，为开发团队提供详细的技术实现指导。

### 1.2 适用范围
- 后端开发人员
- 前端开发人员
- 测试人员
- 项目经理

### 1.3 参考文档
- 需求文档
- 系统架构文档
- 数据库设计文档

## 2. 系统详细设计

### 2.1 模块设计概述

系统采用四层模块架构设计：

```
依赖管理层 (Dependencies)
    ↓
框架封装层 (Framework)
    ↓
业务模块层 (Modules)
    ↓
启动服务层 (Server)
```

### 2.2 核心业务模块设计

#### 2.2.1 用户管理模块 (admin-module-system)

**模块职责**：
- 用户信息管理
- 用户认证与授权
- 用户状态控制
- 密码安全管理

**核心组件**：
```java
// API层
com.admin.module.system.api.user.UserApi
com.admin.module.system.api.user.dto.UserCreateReqDTO
com.admin.module.system.api.user.dto.UserUpdateReqDTO
com.admin.module.system.api.user.dto.UserRespDTO

// BIZ层
com.admin.module.system.controller.admin.user.UserController
com.admin.module.system.service.user.UserService
com.admin.module.system.service.user.UserServiceImpl
com.admin.module.system.dal.dataobject.user.UserDO
com.admin.module.system.dal.mysql.user.UserMapper
```

**关键业务逻辑**：
1. **用户注册流程**
   - 参数校验（用户名、邮箱、手机号唯一性）
   - 密码加密（BCrypt）
   - 默认角色分配
   - 用户状态初始化

2. **用户登录流程**
   - 用户名/邮箱/手机号登录支持
   - 密码验证
   - 登录失败次数控制
   - 账户锁定机制
   - JWT Token生成

3. **密码安全策略**
   - 密码复杂度要求
   - 密码定期更新提醒
   - 密码历史记录防重复

#### 2.2.2 权限管理模块

**模块职责**：
- 角色权限管理
- 菜单权限控制
- 数据权限控制
- 权限缓存管理

**核心组件**：
```java
// 角色管理
com.admin.module.system.api.permission.RoleApi
com.admin.module.system.service.permission.RoleService

// 菜单管理
com.admin.module.system.api.permission.MenuApi
com.admin.module.system.service.permission.MenuService

// 权限校验
com.admin.module.system.service.permission.PermissionService
```

**权限模型设计**：
```
用户 (User) ←→ 角色 (Role) ←→ 菜单权限 (Menu)
     ↓              ↓              ↓
  用户信息        角色信息        权限标识
```

#### 2.2.3 基础设施模块 (admin-module-infra)

**模块职责**：
- 文件存储管理
- 系统配置管理
- 数据字典管理
- 通知公告管理

**文件存储设计**：
```java
// 文件服务接口
public interface FileService {
    String upload(byte[] content, String path);
    void delete(String url);
    byte[] getContent(String url);
}

// 存储策略
- LocalFileService: 本地文件存储
- MinIOFileService: MinIO对象存储
- OSSFileService: 阿里云OSS存储
```

### 2.3 框架封装层设计

#### 2.3.1 Web框架封装 (admin-spring-boot-starter-web)

**功能特性**：
- 统一异常处理
- 统一响应格式
- 请求日志记录
- 跨域配置
- 参数校验

**核心组件**：
```java
// 全局异常处理
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(ServiceException.class)
    public CommonResult<?> serviceExceptionHandler(ServiceException ex) {
        return CommonResult.error(ex.getCode(), ex.getMessage());
    }
}

// 统一响应格式
public class CommonResult<T> {
    private Integer code;
    private String msg;
    private T data;
}
```

#### 2.3.2 安全框架封装 (admin-spring-boot-starter-security)

**安全特性**：
- JWT认证
- 权限拦截
- 接口鉴权
- 防重放攻击
- XSS防护

**认证流程设计**：
```
1. 用户登录 → 2. 生成JWT Token → 3. 返回Token
                        ↓
4. 请求携带Token → 5. Token验证 → 6. 权限校验 → 7. 业务处理
```

#### 2.3.3 数据访问封装 (admin-spring-boot-starter-mybatis)

**功能特性**：
- MyBatis-Plus集成（使用mybatis-plus-spring-boot3-starter）
- MapStruct对象转换集成
- 分页插件配置
- 乐观锁插件
- 逻辑删除
- 自动填充

**基础实体设计**：
```java
@Data
public abstract class BaseDO {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    @TableField(fill = FieldFill.INSERT)
    private String createBy;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private String updateBy;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
    
    @Version
    private Integer version;
    
    @TableLogic
    private Boolean deleted;
}
```

## 3. 接口设计

### 3.1 RESTful API设计规范

#### 3.1.1 URL设计规范
```
# 资源命名
GET    /admin-api/system/users          # 获取用户列表
GET    /admin-api/system/users/{id}     # 获取单个用户
POST   /admin-api/system/users          # 创建用户
PUT    /admin-api/system/users/{id}     # 更新用户
DELETE /admin-api/system/users/{id}     # 删除用户

# 子资源
GET    /admin-api/system/users/{id}/roles  # 获取用户角色
POST   /admin-api/system/users/{id}/roles  # 分配用户角色
```

#### 3.1.2 HTTP状态码规范
```
200 OK          - 请求成功
201 Created     - 资源创建成功
400 Bad Request - 请求参数错误
401 Unauthorized - 未认证
403 Forbidden   - 无权限
404 Not Found   - 资源不存在
500 Internal Server Error - 服务器内部错误
```

#### 3.1.3 响应格式规范
```json
{
  "code": 0,
  "msg": "success",
  "data": {
    // 业务数据
  }
}

// 分页响应
{
  "code": 0,
  "msg": "success",
  "data": {
    "list": [],
    "total": 100,
    "pageNo": 1,
    "pageSize": 10
  }
}
```

### 3.2 核心接口设计

#### 3.2.1 用户管理接口

**1. 用户登录接口**
```yaml
POST /admin-api/system/auth/login
Content-Type: application/json

# 请求参数
{
  "username": "admin",
  "password": "123456",
  "captcha": "1234",
  "uuid": "uuid-string"
}

# 响应结果
{
  "code": 0,
  "msg": "success",
  "data": {
    "accessToken": "jwt-token",
    "refreshToken": "refresh-token",
    "expiresTime": 1640995200000,
    "user": {
      "id": 1,
      "username": "admin",
      "nickname": "管理员",
      "avatar": "http://example.com/avatar.jpg"
    }
  }
}
```

**2. 用户列表接口**
```yaml
GET /admin-api/system/users
Authorization: Bearer {token}

# 查询参数
?pageNo=1&pageSize=10&username=admin&status=1

# 响应结果
{
  "code": 0,
  "msg": "success",
  "data": {
    "list": [
      {
        "id": 1,
        "username": "admin",
        "nickname": "管理员",
        "email": "admin@example.com",
        "phone": "13800138000",
        "status": 1,
        "createTime": "2023-01-01 00:00:00"
      }
    ],
    "total": 1
  }
}
```

**3. 创建用户接口**
```yaml
POST /admin-api/system/users
Authorization: Bearer {token}
Content-Type: application/json

# 请求参数
{
  "username": "testuser",
  "nickname": "测试用户",
  "email": "test@example.com",
  "phone": "13800138001",
  "password": "123456",
  "roleIds": [2, 3]
}

# 响应结果
{
  "code": 0,
  "msg": "success",
  "data": {
    "id": 2
  }
}
```

#### 3.2.2 角色权限接口

**1. 角色列表接口**
```yaml
GET /admin-api/system/roles
Authorization: Bearer {token}

# 响应结果
{
  "code": 0,
  "msg": "success",
  "data": [
    {
      "id": 1,
      "roleName": "超级管理员",
      "roleCode": "SUPER_ADMIN",
      "status": 1,
      "createTime": "2023-01-01 00:00:00"
    }
  ]
}
```

**2. 菜单权限树接口**
```yaml
GET /admin-api/system/menus/tree
Authorization: Bearer {token}

# 响应结果
{
  "code": 0,
  "msg": "success",
  "data": [
    {
      "id": 1,
      "menuName": "系统管理",
      "menuType": 1,
      "path": "/system",
      "icon": "system",
      "children": [
        {
          "id": 2,
          "menuName": "用户管理",
          "menuType": 2,
          "path": "/system/user",
          "permission": "system:user:list"
        }
      ]
    }
  ]
}
```

### 3.3 接口安全设计

#### 3.3.1 认证机制
```java
// JWT Token结构
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "userId": 1,
    "username": "admin",
    "roles": ["SUPER_ADMIN"],
    "exp": 1640995200,
    "iat": 1640908800
  }
}
```

#### 3.3.2 权限校验
```java
// 注解式权限校验
@PreAuthorize("@ss.hasPermission('system:user:create')")
@PostMapping("/users")
public CommonResult<Long> createUser(@RequestBody UserCreateReqVO reqVO) {
    return success(userService.createUser(reqVO));
}

// 编程式权限校验
if (!permissionService.hasPermission("system:user:update")) {
    throw new ServiceException(FORBIDDEN);
}
```

#### 3.3.3 接口限流
```java
// 基于注解的限流
@RateLimiter(key = "login", time = 60, count = 5)
@PostMapping("/login")
public CommonResult<AuthLoginRespVO> login(@RequestBody AuthLoginReqVO reqVO) {
    return success(authService.login(reqVO));
}
```

## 4. 组件设计

### 4.1 通用组件设计

#### 4.1.1 分页组件
```java
// 分页请求基类
@Data
public class PageParam {
    @Min(value = 1, message = "页码最小值为 1")
    private Integer pageNo = 1;
    
    @Range(min = 1, max = 100, message = "页面大小范围为 1-100")
    private Integer pageSize = 10;
}

// 分页响应基类
@Data
public class PageResult<T> {
    private List<T> list;
    private Long total;
}
```

#### 4.1.2 缓存组件
```java
// 缓存服务接口
public interface CacheService {
    void set(String key, Object value, Duration timeout);
    <T> T get(String key, Class<T> type);
    void delete(String key);
    void deleteByPattern(String pattern);
}

// Redis缓存实现
@Service
public class RedisCacheService implements CacheService {
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 实现方法...
}
```

#### 4.1.3 文件上传组件
```java
// 文件上传配置
@ConfigurationProperties(prefix = "admin.file")
@Data
public class FileProperties {
    private String basePath = "/uploads";
    private Long maxSize = 10 * 1024 * 1024L; // 10MB
    private String[] allowedTypes = {"jpg", "jpeg", "png", "gif", "pdf", "doc", "docx"};
}

// 文件上传服务
@Service
public class FileUploadService {
    public FileUploadResult upload(MultipartFile file, String module) {
        // 1. 文件校验
        validateFile(file);
        
        // 2. 生成文件路径
        String filePath = generateFilePath(file, module);
        
        // 3. 保存文件
        saveFile(file, filePath);
        
        // 4. 记录文件信息
        return recordFileInfo(file, filePath);
    }
}
```

### 4.2 业务组件设计

#### 4.2.1 操作日志组件
```java
// 操作日志注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface OperateLog {
    String module() default "";
    String name() default "";
    OperateTypeEnum type() default OperateTypeEnum.OTHER;
}

// 操作日志切面
@Aspect
@Component
public class OperateLogAspect {
    @Around("@annotation(operateLog)")
    public Object around(ProceedingJoinPoint joinPoint, OperateLog operateLog) {
        // 记录操作日志逻辑
    }
}
```

#### 4.2.2 数据权限组件
```java
// 数据权限注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DataPermission {
    String[] value() default {};
}

// 数据权限拦截器
@Component
public class DataPermissionInterceptor implements Interceptor {
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        // 动态添加数据权限SQL条件
        return invocation.proceed();
    }
}
```

#### 4.2.3 Excel导入导出组件
```java
// Excel导出服务
@Service
public class ExcelExportService {
    public <T> void export(HttpServletResponse response, String fileName, 
                          Class<T> clazz, List<T> data) {
        // 使用EasyExcel导出
        EasyExcel.write(response.getOutputStream(), clazz)
                .sheet("数据")
                .doWrite(data);
    }
}

// Excel导入服务
@Service
public class ExcelImportService {
    public <T> List<T> importExcel(MultipartFile file, Class<T> clazz) {
        // 使用EasyExcel导入
        return EasyExcel.read(file.getInputStream())
                .head(clazz)
                .sheet()
                .doReadSync();
    }
}
```

## 5. 安全设计

### 5.1 认证安全

#### 5.1.1 密码安全策略
```java
// 密码编码器配置
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}

// 密码复杂度校验
public class PasswordValidator {
    private static final String PASSWORD_PATTERN = 
        "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$";
    
    public static boolean isValid(String password) {
        return password.matches(PASSWORD_PATTERN);
    }
}
```

#### 5.1.2 登录安全控制
```java
// 登录失败次数控制
@Service
public class LoginAttemptService {
    private static final int MAX_ATTEMPT = 5;
    private static final int LOCK_TIME_DURATION = 30; // 分钟
    
    public void loginFailed(String username) {
        int attempts = getAttempts(username);
        if (attempts >= MAX_ATTEMPT) {
            lockUser(username);
        }
    }
}
```

### 5.2 接口安全

#### 5.2.1 XSS防护
```java
// XSS过滤器
@Component
public class XssFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        XssHttpServletRequestWrapper wrappedRequest = 
            new XssHttpServletRequestWrapper((HttpServletRequest) request);
        chain.doFilter(wrappedRequest, response);
    }
}
```

#### 5.2.2 CSRF防护
```java
// CSRF配置
@Configuration
public class CsrfConfig {
    @Bean
    public CsrfTokenRepository csrfTokenRepository() {
        HttpSessionCsrfTokenRepository repository = 
            new HttpSessionCsrfTokenRepository();
        repository.setHeaderName("X-CSRF-TOKEN");
        return repository;
    }
}
```

### 5.3 数据安全

#### 5.3.1 敏感数据加密
```java
// 敏感字段加密
@Component
public class SensitiveDataEncryptor {
    @Autowired
    private AESUtil aesUtil;
    
    public String encrypt(String plainText) {
        return aesUtil.encrypt(plainText);
    }
    
    public String decrypt(String cipherText) {
        return aesUtil.decrypt(cipherText);
    }
}
```

#### 5.3.2 SQL注入防护
```java
// 使用参数化查询
@Mapper
public interface UserMapper extends BaseMapper<UserDO> {
    @Select("SELECT * FROM sys_user WHERE username = #{username}")
    UserDO selectByUsername(@Param("username") String username);
}
```

## 6. 性能设计

### 6.1 缓存策略

#### 6.1.1 多级缓存架构
```
L1: 本地缓存 (Caffeine)
    ↓ (miss)
L2: 分布式缓存 (Redis)
    ↓ (miss)
L3: 数据库 (MySQL)
```

#### 6.1.2 缓存实现
```java
// 缓存配置
@Configuration
@EnableCaching
public class CacheConfig {
    @Bean
    public CacheManager cacheManager() {
        RedisCacheManager.Builder builder = RedisCacheManager
            .RedisCacheManagerBuilder
            .fromConnectionFactory(redisConnectionFactory())
            .cacheDefaults(cacheConfiguration());
        return builder.build();
    }
}

// 缓存使用
@Service
public class UserService {
    @Cacheable(value = "user", key = "#id")
    public UserDO getById(Long id) {
        return userMapper.selectById(id);
    }
    
    @CacheEvict(value = "user", key = "#user.id")
    public void updateUser(UserDO user) {
        userMapper.updateById(user);
    }
}
```

### 6.2 数据库优化

#### 6.2.1 连接池配置
```yaml
spring:
  datasource:
    type: com.zaxxer.hikari.HikariDataSource
    hikari:
      minimum-idle: 10
      maximum-pool-size: 20
      idle-timeout: 600000
      max-lifetime: 1800000
      connection-timeout: 30000
```

#### 6.2.2 分页优化
```java
// 分页插件配置
@Configuration
public class MybatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
}
```

### 6.3 异步处理

#### 6.3.1 异步任务配置
```java
@Configuration
@EnableAsync
public class AsyncConfig {
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(200);
        executor.setThreadNamePrefix("async-");
        executor.initialize();
        return executor;
    }
}
```

#### 6.3.2 异步任务使用
```java
@Service
public class NotificationService {
    @Async("taskExecutor")
    public void sendEmailAsync(String to, String subject, String content) {
        // 异步发送邮件
        emailService.send(to, subject, content);
    }
}
```

## 7. 监控设计

### 7.1 应用监控

#### 7.1.1 健康检查
```java
// 自定义健康检查
@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    @Autowired
    private DataSource dataSource;
    
    @Override
    public Health health() {
        try (Connection connection = dataSource.getConnection()) {
            if (connection.isValid(1)) {
                return Health.up().withDetail("database", "Available").build();
            }
        } catch (Exception e) {
            return Health.down(e).build();
        }
        return Health.down().withDetail("database", "Unavailable").build();
    }
}
```

#### 7.1.2 性能监控
```java
// 方法执行时间监控
@Aspect
@Component
public class PerformanceMonitorAspect {
    @Around("@annotation(com.admin.framework.common.annotation.Monitor)")
    public Object monitor(ProceedingJoinPoint joinPoint) throws Throwable {
        long startTime = System.currentTimeMillis();
        try {
            return joinPoint.proceed();
        } finally {
            long endTime = System.currentTimeMillis();
            String methodName = joinPoint.getSignature().getName();
            log.info("Method {} executed in {} ms", methodName, endTime - startTime);
        }
    }
}
```

### 7.2 日志设计

#### 7.2.1 日志配置
```xml
<!-- logback-spring.xml -->
<configuration>
    <springProfile name="dev">
        <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
            <encoder>
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            </encoder>
        </appender>
        <root level="INFO">
            <appender-ref ref="CONSOLE"/>
        </root>
    </springProfile>
    
    <springProfile name="prod">
        <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>logs/admin.log</file>
            <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                <fileNamePattern>logs/admin.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
                <maxFileSize>100MB</maxFileSize>
                <maxHistory>30</maxHistory>
            </rollingPolicy>
            <encoder>
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            </encoder>
        </appender>
        <root level="INFO">
            <appender-ref ref="FILE"/>
        </root>
    </springProfile>
</configuration>
```

#### 7.2.2 结构化日志
```java
// 结构化日志工具
@Component
public class StructuredLogger {
    private static final Logger log = LoggerFactory.getLogger(StructuredLogger.class);
    
    public void logUserAction(Long userId, String action, String resource) {
        MDC.put("userId", String.valueOf(userId));
        MDC.put("action", action);
        MDC.put("resource", resource);
        log.info("User action performed");
        MDC.clear();
    }
}
```

## 8. 部署设计

### 8.1 Docker化部署

#### 8.1.1 Dockerfile
```dockerfile
FROM openjdk:11-jre-slim

VOLUME /tmp

COPY target/admin-server.jar app.jar

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "/app.jar"]
```

#### 8.1.2 docker-compose.yml
```yaml
version: '3.8'
services:
  admin-app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/admin
    depends_on:
      - mysql
      - redis
  
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: admin
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
  
  redis:
    image: redis:6.2
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  mysql_data:
  redis_data:
```

### 8.2 配置管理

#### 8.2.1 多环境配置
```yaml
# application.yml
spring:
  profiles:
    active: @spring.profiles.active@
  application:
    name: admin-server

---
# application-dev.yml
spring:
  config:
    activate:
      on-profile: dev
  datasource:
    url: jdbc:mysql://localhost:3306/admin_dev
    username: root
    password: root

---
# application-prod.yml
spring:
  config:
    activate:
      on-profile: prod
  datasource:
    url: ${DB_URL}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
```

## 9. 测试设计

### 9.1 单元测试

#### 9.1.1 Service层测试
```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    @Mock
    private UserMapper userMapper;
    
    @InjectMocks
    private UserServiceImpl userService;
    
    @Test
    void testCreateUser() {
        // Given
        UserCreateReqVO reqVO = new UserCreateReqVO();
        reqVO.setUsername("test");
        reqVO.setPassword("123456");
        
        UserDO userDO = new UserDO();
        userDO.setId(1L);
        
        when(userMapper.insert(any(UserDO.class))).thenReturn(1);
        
        // When
        Long userId = userService.createUser(reqVO);
        
        // Then
        assertThat(userId).isNotNull();
        verify(userMapper).insert(any(UserDO.class));
    }
}
```

#### 9.1.2 Controller层测试
```java
@WebMvcTest(UserController.class)
class UserControllerTest {
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private UserService userService;
    
    @Test
    void testCreateUser() throws Exception {
        // Given
        when(userService.createUser(any())).thenReturn(1L);
        
        // When & Then
        mockMvc.perform(post("/admin-api/system/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"username\":\"test\",\"password\":\"123456\"}"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.code").value(0))
                .andExpect(jsonPath("$.data").value(1));
    }
}
```

### 9.2 集成测试

#### 9.2.1 数据库集成测试
```java
@SpringBootTest
@Transactional
class UserServiceIntegrationTest {
    @Autowired
    private UserService userService;
    
    @Test
    void testUserCRUD() {
        // Create
        UserCreateReqVO createReq = new UserCreateReqVO();
        createReq.setUsername("integration_test");
        createReq.setPassword("123456");
        Long userId = userService.createUser(createReq);
        
        // Read
        UserDO user = userService.getUser(userId);
        assertThat(user.getUsername()).isEqualTo("integration_test");
        
        // Update
        UserUpdateReqVO updateReq = new UserUpdateReqVO();
        updateReq.setId(userId);
        updateReq.setNickname("Updated Name");
        userService.updateUser(updateReq);
        
        // Verify Update
        user = userService.getUser(userId);
        assertThat(user.getNickname()).isEqualTo("Updated Name");
        
        // Delete
        userService.deleteUser(userId);
        
        // Verify Delete
        assertThatThrownBy(() -> userService.getUser(userId))
                .isInstanceOf(ServiceException.class);
    }
}
```

---

**文档版本**: v1.0  
**最后更新**: 2024-01-15  
**文档状态**: 草稿
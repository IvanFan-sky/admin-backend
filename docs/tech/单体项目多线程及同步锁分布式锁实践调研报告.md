# 单体项目多线程及同步锁分布式锁实践调研报告

## 1. 概述

本报告针对单体项目中多线程编程、同步锁机制以及分布式锁的实践进行深入调研，为项目开发提供技术指导和最佳实践建议。

## 2. Java多线程编程基础

### 2.1 线程创建方式

#### 2.1.1 继承Thread类
```java
public class MyThread extends Thread {
    @Override
    public void run() {
        // 线程执行逻辑
    }
}
```

**优点**：编写简单，可直接使用this获取当前线程
**缺点**：由于已继承Thread类，无法再继承其他父类

#### 2.1.2 实现Runnable接口
```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 线程执行逻辑
    }
}
```

**优点**：可以继承其他类，多个线程可共享同一个目标对象
**缺点**：需要使用Thread.currentThread()获取当前线程

#### 2.1.3 实现Callable接口
```java
public class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        // 有返回值的线程执行逻辑
        return "result";
    }
}
```

**优点**：支持返回值和异常抛出
**缺点**：编程相对复杂

#### 2.1.4 使用线程池
```java
ExecutorService executor = new ThreadPoolExecutor(
    corePoolSize,
    maximumPoolSize,
    keepAliveTime,
    TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(),
    new ThreadFactoryBuilder().setNameFormat("thread-%d").build()
);
```

### 2.2 线程池最佳实践

#### 2.2.1 线程池参数配置
- **corePoolSize**：核心线程数
- **maximumPoolSize**：最大线程数
- **keepAliveTime**：线程空闲时间
- **workQueue**：工作队列
- **threadFactory**：线程工厂
- **handler**：拒绝策略

#### 2.2.2 线程数量计算
- **CPU密集型**：线程数 = CPU核数 + 1
- **IO密集型**：线程数 = (IO时间/CPU占用时间 + 1) × CPU核数

#### 2.2.3 线程池使用注意事项
1. **避免使用Executors创建线程池**，防止OOM风险
2. **为线程池命名**，便于问题定位
3. **不同业务使用不同线程池**，避免相互影响
4. **监控线程池运行状态**

## 3. 同步锁机制

### 3.1 synchronized关键字

#### 3.1.1 特性
- JVM底层实现的关键字
- 非公平锁
- 自动释放锁
- 支持锁升级：偏向锁 → 轻量级锁 → 重量级锁

#### 3.1.2 使用方式
```java
// 同步方法
public synchronized void method() {
    // 同步代码
}

// 同步代码块
synchronized (this) {
    // 同步代码
}
```

### 3.2 ReentrantLock

#### 3.2.1 特性
- API层面的锁实现
- 支持公平锁和非公平锁
- 需要手动释放锁
- 支持条件变量(Condition)

#### 3.2.2 使用方式
```java
ReentrantLock lock = new ReentrantLock();
try {
    lock.lock();
    // 临界区代码
} finally {
    lock.unlock();
}
```

### 3.3 volatile关键字

#### 3.3.1 特性
- 保证可见性
- 禁止指令重排
- 不保证原子性

#### 3.3.2 使用场景
```java
private volatile boolean flag = false;

// 单例模式双重检查锁
public class Singleton {
    private volatile static Singleton instance;
    
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

### 3.4 原子类(Atomic)

#### 3.4.1 常用原子类
- AtomicInteger
- AtomicLong
- AtomicReference
- AtomicStampedReference (解决ABA问题)

#### 3.4.2 CAS原理
- Compare And Swap
- 基于CPU原语实现
- 无锁化编程

```java
AtomicInteger counter = new AtomicInteger(0);
counter.incrementAndGet(); // 原子性自增
```

## 4. ThreadLocal使用实践

### 4.1 ThreadLocal原理
- 每个Thread维护一个ThreadLocalMap
- ThreadLocal作为key，存储线程私有数据
- 实现线程间数据隔离

### 4.2 ThreadLocal与线程池的问题

#### 4.2.1 内存泄漏问题
```java
// 错误示例
ThreadLocal<List<User>> threadLocal = new ThreadLocal<>();
threadLocal.set(bigList); // 未调用remove()可能导致内存泄漏
```

#### 4.2.2 数据污染问题
线程池复用线程时，ThreadLocal中的旧数据可能被新任务获取

#### 4.2.3 最佳实践
```java
ThreadLocal<User> threadLocal = new ThreadLocal<>();
try {
    threadLocal.set(user);
    // 业务逻辑
} finally {
    threadLocal.remove(); // 必须清理
}
```

## 5. 分布式锁实现方案

### 5.1 Redis分布式锁

#### 5.1.1 基本实现
```java
// 获取锁
String result = jedis.set(key, value, "NX", "PX", expireTime);
if ("OK".equals(result)) {
    // 获取锁成功
}

// 释放锁(Lua脚本保证原子性)
String script = "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                "return redis.call('del', KEYS[1]) " +
                "else return 0 end";
jedis.eval(script, Collections.singletonList(key), Collections.singletonList(value));
```

#### 5.1.2 Redis分布式锁问题
1. **锁超时问题**：业务执行时间超过锁过期时间
2. **主从切换问题**：主节点宕机，从节点可能未同步锁信息
3. **时钟跳跃问题**：服务器时钟不同步

### 5.2 Redisson分布式锁

#### 5.2.1 特性
- 自动续期机制(Watch Dog)
- 支持多种锁类型
- 支持Redis集群

#### 5.2.2 使用示例
```java
RedissonClient redisson = Redisson.create(config);
RLock lock = redisson.getLock("myLock");

try {
    // 尝试获取锁，最多等待100秒，锁定10秒后自动释放
    boolean isLocked = lock.tryLock(100, 10, TimeUnit.SECONDS);
    if (isLocked) {
        // 业务逻辑
    }
} finally {
    if (lock.isHeldByCurrentThread()) {
        lock.unlock();
    }
}
```

#### 5.2.3 Watch Dog机制
- 默认每10秒续期一次
- 重置锁的过期时间
- 续期3次未释放则主动释放锁

### 5.3 ZooKeeper分布式锁

#### 5.3.1 实现原理
- 利用ZooKeeper的临时顺序节点
- 通过节点顺序判断锁的获取
- 节点删除时自动释放锁

#### 5.3.2 优缺点
**优点**：
- 强一致性
- 自动故障恢复
- 支持阻塞等待

**缺点**：
- 性能相对较低
- 依赖ZooKeeper集群
- 实现复杂度高

### 5.4 RedLock算法

#### 5.4.1 实现原理
1. Redis集群无主从之分
2. 客户端对多个Redis节点循环执行setnx操作
3. 超过一半节点返回成功才算获取锁成功
4. 总耗时不能超过key的过期时间

#### 5.4.2 使用场景
适用于对一致性要求极高的场景

## 6. 并发安全最佳实践

### 6.1 线程安全三要素
1. **原子性**：使用synchronized、Lock、Atomic类
2. **可见性**：使用volatile、synchronized
3. **有序性**：使用happens-before原则

### 6.2 集合类并发安全

#### 6.2.1 线程安全的集合
- Vector (性能较低)
- Collections.synchronizedList()
- CopyOnWriteArrayList (读多写少场景)
- ConcurrentHashMap

#### 6.2.2 选择建议
```java
// 读多写少场景
List<String> list = new CopyOnWriteArrayList<>();

// 高并发Map场景
Map<String, Object> map = new ConcurrentHashMap<>();
```

### 6.3 死锁预防
1. **避免嵌套锁**
2. **统一锁顺序**
3. **使用超时锁**
4. **锁粒度最小化**

## 7. 性能优化建议

### 7.1 锁优化策略
1. **减少锁的持有时间**
2. **降低锁的粒度**
3. **使用读写锁分离**
4. **锁分段技术**

### 7.2 无锁编程
1. **使用Atomic类**
2. **CAS操作**
3. **ThreadLocal**
4. **不可变对象**

### 7.3 监控与调优
1. **线程池监控**
2. **锁竞争监控**
3. **GC监控**
4. **性能测试**

## 8. 实际应用场景

### 8.1 单体应用场景
- 缓存更新同步
- 计数器操作
- 资源池管理
- 定时任务调度

### 8.2 分布式场景
- 防止重复提交
- 库存扣减
- 分布式任务调度
- 配置更新同步

## 9. 总结与建议

### 9.1 技术选型建议
1. **单体应用**：优先使用JUC包下的并发工具
2. **分布式环境**：推荐使用Redisson实现分布式锁
3. **高可用要求**：考虑使用ZooKeeper或RedLock

### 9.2 开发规范
1. **合理设计线程池参数**
2. **及时释放锁资源**
3. **避免长时间持有锁**
4. **做好异常处理**
5. **充分的单元测试**

### 9.3 运维监控
1. **建立完善的监控体系**
2. **设置合理的告警阈值**
3. **定期进行性能测试**
4. **建立故障应急预案**

通过合理运用多线程编程技术和分布式锁机制，可以显著提升系统的并发处理能力和数据一致性保障，为业务发展提供强有力的技术支撑。